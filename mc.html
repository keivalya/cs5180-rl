<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Monte Carlo Methods</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #121a33;
            --panel2: #0f1630;
            --text: #e9eefc;
            --muted: #a9b4d6;
            --accent: #7aa2ff;
            --good: #76f7c4;
            --warn: #ffcc66;
            --bad: #ff6b6b;
            --line: #24305a;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            background: radial-gradient(1200px 700px at 20% 10%, #1a2550 0%, var(--bg) 60%) fixed;
            color: var(--text);
        }

        header {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, .06);
            background: rgba(0, 0, 0, .18);
            position: sticky;
            top: 0;
            backdrop-filter: blur(6px);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        header h1 {
            font-size: 15px;
            margin: 0;
            letter-spacing: .2px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .tag {
            font-size: 12px;
            padding: 3px 8px;
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 999px;
            background: rgba(255, 255, 255, .04);
            color: var(--muted);
        }

        nav a {
            color: var(--muted);
            text-decoration: none;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .04);
            font-size: 12px;
        }

        nav a:hover {
            background: rgba(255, 255, 255, .08);
            color: var(--text);
        }

        .wrap {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 14px;
            padding: 14px;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (max-width: 1000px) {
            .wrap {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .03));
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 16px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .card h2 {
            margin: 0;
            padding: 12px 14px;
            font-size: 13px;
            letter-spacing: .25px;
            color: var(--muted);
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            background: rgba(255, 255, 255, .03);
        }

        .card .body {
            padding: 12px 14px;
        }

        .help {
            font-size: 12px;
            line-height: 1.45;
            color: var(--muted);
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(0, 0, 0, .22);
            color: var(--text);
        }

        .split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .col {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .chip {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 10px;
            background: rgba(0, 0, 0, .25);
            border: 1px solid rgba(255, 255, 255, .08);
            color: var(--muted);
        }

        label {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="number"],
        select {
            width: 100%;
            padding: 9px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(0, 0, 0, .25);
            color: var(--text);
            outline: none;
        }

        select {
            cursor: pointer;
        }

        .btn {
            padding: 10px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            letter-spacing: .2px;
            transition: transform .05s ease, background .12s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, .10);
        }

        .btn:active {
            transform: scale(.99);
        }

        .btn.primary {
            background: rgba(122, 162, 255, .18);
            border-color: rgba(122, 162, 255, .35);
        }

        .btn.primary:hover {
            background: rgba(122, 162, 255, .24);
        }

        .btn.danger {
            background: rgba(255, 107, 107, .14);
            border-color: rgba(255, 107, 107, .35);
        }

        .btn.danger:hover {
            background: rgba(255, 107, 107, .2);
        }

        .canvasWrap {
            background: rgba(0, 0, 0, .22);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 14px;
            padding: 10px;
            position: relative;
        }

        .miniTitle {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        canvas {
            width: 100%;
            display: block;
            border-radius: 10px;
            background: #0b1228;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        th,
        td {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
        }

        th {
            color: var(--muted);
            font-weight: 600;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
            font-size: 11px;
            color: var(--muted);
        }

        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .swatch {
            width: 12px;
            height: 12px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, .16);
        }

        .math {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, .2);
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .08);
        }
    </style>
</head>

<body>
    <header>
        <h1>
            Monte Carlo Methods
            <span class="tag">First-visit MC</span>
            <span class="tag">Every-visit MC</span>
            <span class="tag">Exploring Starts</span>
        </h1>
        <nav class="row">
            <a href="index.html">← Home</a>
        </nav>
    </header>

    <div class="wrap">
        <section class="card">
            <h2>Controls</h2>
            <div class="body">
                <div class="col">
                    <label>Return estimator</label>
                    <select id="estimator">
                        <option value="first" selected>First-visit MC</option>
                        <option value="every">Every-visit MC</option>
                    </select>
                </div>

                <div class="spacer" style="height:10px;"></div>

                <div class="split">
                    <div class="col">
                        <label>Discount γ <span class="kbd" id="gammaVal">0.90</span></label>
                        <input id="gamma" type="range" min="0" max="0.99" value="0.9" step="0.01" />
                    </div>
                    <div class="col">
                        <label>Episodes / batch</label>
                        <input id="episodes" type="number" min="1" max="200" value="20" />
                    </div>
                </div>

                <div class="spacer" style="height:10px;"></div>

                <div class="split">
                    <div class="col">
                        <label>Policy</label>
                        <select id="policy">
                            <option value="uniform" selected>Uniform random</option>
                            <option value="epsilon">ε-soft (greedy from V)</option>
                        </select>
                    </div>
                    <div class="col">
                        <label>Exploring starts</label>
                        <select id="starts">
                            <option value="all" selected>Random start state</option>
                            <option value="fixed">Fixed start (1,1)</option>
                        </select>
                    </div>
                </div>

                <div class="spacer" style="height:10px;"></div>

                <div class="row">
                    <button class="btn primary" id="reset">Reset</button>
                    <button class="btn" id="run">Run batch</button>
                    <button class="btn" id="play">Play</button>
                    <button class="btn danger" id="stop">Stop</button>
                </div>

                <div style="margin-top:12px;">
                    <div class="chips">
                        <div class="chip">episodes: <b id="episodeChip">0</b></div>
                        <div class="chip">last return: <b id="returnChip">–</b></div>
                        <div class="chip">selected state: <b id="stateChip">–</b></div>
                    </div>
                </div>
            </div>

            <h2>MC chapter cheat sheet</h2>
            <div class="body">
                <div class="help">
                    Monte Carlo methods estimate value functions from complete episodes.
                    Instead of bootstrapping, they average observed returns. In the DP chapter we
                    assumed a model; here we learn from sampled trajectories.
                </div>
                <div class="spacer" style="height:10px;"></div>
                <ul class="help" style="margin:0 0 8px 18px; padding:0;">
                    <li><b>First-visit MC</b>: update V(s) using the first time s appears in an episode.</li>
                    <li><b>Every-visit MC</b>: update V(s) for all occurrences in the episode.</li>
                    <li><b>Exploring starts</b>: start episodes from random states to ensure exploration.</li>
                </ul>
                <div class="math">V(s) ← average of returns G<sub>t</sub> observed after visits to s.</div>
            </div>

            <h2>Selected-state returns</h2>
            <div class="body">
                <div class="help" id="returnsHint">Click a state to see sampled returns from recent episodes.</div>
                <div class="spacer" style="height:10px;"></div>
                <table id="returnsTable">
                    <thead>
                        <tr>
                            <th>episode</th>
                            <th>visit step</th>
                            <th>return G</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </section>

        <section class="card">
            <h2>Visualization</h2>
            <div class="body">
                <div class="canvasWrap">
                    <div class="miniTitle"><span>4×4 gridworld</span> <b>MC value estimates</b></div>
                    <canvas id="gridCanvas" width="1000" height="600"></canvas>
                    <div class="legend">
                        <span><span class="swatch" style="background:#1b2657"></span> low value</span>
                        <span><span class="swatch" style="background:#7aa2ff"></span> high value</span>
                        <span><span class="swatch" style="background:#76f7c4"></span> greedy action</span>
                    </div>
                </div>

                <div style="height:12px;"></div>

                <div class="canvasWrap">
                    <div class="miniTitle"><span>Learning curve</span> <b>average return per episode</b></div>
                    <canvas id="returnCanvas" width="1000" height="280" style="height:280px;"></canvas>
                </div>
            </div>
        </section>
    </div>

    <script>
        const GRID = { rows: 4, cols: 4 };
        const ACTIONS = [
            { name: "N", dr: -1, dc: 0 },
            { name: "S", dr: 1, dc: 0 },
            { name: "W", dr: 0, dc: -1 },
            { name: "E", dr: 0, dc: 1 },
        ];
        const TERMINALS = [
            { r: 0, c: 0, reward: 0 },
            { r: GRID.rows - 1, c: GRID.cols - 1, reward: 0 },
        ];
        const STEP_REWARD = -1;
        const MAX_STEPS = 50;

        const estimatorEl = document.getElementById("estimator");
        const gammaEl = document.getElementById("gamma");
        const gammaValEl = document.getElementById("gammaVal");
        const episodesEl = document.getElementById("episodes");
        const policyEl = document.getElementById("policy");
        const startsEl = document.getElementById("starts");

        const episodeChip = document.getElementById("episodeChip");
        const returnChip = document.getElementById("returnChip");
        const stateChip = document.getElementById("stateChip");
        const returnsTable = document.getElementById("returnsTable").querySelector("tbody");
        const returnsHint = document.getElementById("returnsHint");

        const gridCanvas = document.getElementById("gridCanvas");
        const gridCtx = gridCanvas.getContext("2d");
        const returnCanvas = document.getElementById("returnCanvas");
        const returnCtx = returnCanvas.getContext("2d");

        let V = new Array(GRID.rows * GRID.cols).fill(0);
        let returns = Array.from({ length: GRID.rows * GRID.cols }, () => []);
        let episode = 0;
        let avgReturns = [];
        let timer = null;
        let selected = null;
        let recentVisits = [];

        function idx(r, c) {
            return r * GRID.cols + c;
        }

        function isTerminal(r, c) {
            return TERMINALS.some(t => t.r === r && t.c === c);
        }

        function stepDynamics(r, c, action) {
            const nr = r + action.dr;
            const nc = c + action.dc;
            if (nr < 0 || nr >= GRID.rows || nc < 0 || nc >= GRID.cols) {
                return { r2: r, c2: c, reward: STEP_REWARD };
            }
            return { r2: nr, c2: nc, reward: STEP_REWARD };
        }

        function chooseAction(r, c) {
            if (policyEl.value === "uniform") {
                return ACTIONS[Math.floor(Math.random() * ACTIONS.length)];
            }
            const epsilon = 0.2;
            if (Math.random() < epsilon) {
                return ACTIONS[Math.floor(Math.random() * ACTIONS.length)];
            }
            const greedy = greedyActions(r, c);
            return greedy[Math.floor(Math.random() * greedy.length)];
        }

        function greedyActions(r, c) {
            let best = -Infinity;
            let bestAs = [];
            for (const a of ACTIONS) {
                const out = stepDynamics(r, c, a);
                const term = out.reward + parseFloat(gammaEl.value) * V[idx(out.r2, out.c2)];
                if (term > best + 1e-12) {
                    best = term;
                    bestAs = [a];
                } else if (Math.abs(term - best) <= 1e-12) {
                    bestAs.push(a);
                }
            }
            return bestAs;
        }

        function generateEpisode() {
            let r = 1;
            let c = 1;
            if (startsEl.value === "all") {
                r = Math.floor(Math.random() * GRID.rows);
                c = Math.floor(Math.random() * GRID.cols);
            }
            const trajectory = [];
            for (let t = 0; t < MAX_STEPS; t++) {
                if (isTerminal(r, c)) break;
                const action = chooseAction(r, c);
                const out = stepDynamics(r, c, action);
                trajectory.push({ r, c, reward: out.reward });
                r = out.r2;
                c = out.c2;
                if (isTerminal(r, c)) break;
            }
            if (isTerminal(r, c)) {
                trajectory.push({ r, c, reward: 0, terminal: true });
            }
            return trajectory;
        }

        function updateValues(trajectory) {
            const gamma = parseFloat(gammaEl.value);
            let G = 0;
            const visited = new Set();
            for (let t = trajectory.length - 1; t >= 0; t--) {
                const step = trajectory[t];
                G = step.reward + gamma * G;
                const stateKey = `${step.r},${step.c}`;
                const stateIndex = idx(step.r, step.c);
                const firstVisit = !visited.has(stateKey);
                if (estimatorEl.value === "every" || firstVisit) {
                    returns[stateIndex].push(G);
                    V[stateIndex] = average(returns[stateIndex]);
                    recentVisits.push({ episode, step: t, G, r: step.r, c: step.c });
                }
                visited.add(stateKey);
            }
            return G;
        }

        function average(list) {
            if (list.length === 0) return 0;
            return list.reduce((a, b) => a + b, 0) / list.length;
        }

        function runBatch(count) {
            let batchReturn = 0;
            for (let i = 0; i < count; i++) {
                const traj = generateEpisode();
                const epReturn = updateValues(traj);
                batchReturn += epReturn;
                episode += 1;
                avgReturns.push(epReturn);
            }
            const lastReturn = batchReturn / count;
            episodeChip.textContent = episode;
            returnChip.textContent = lastReturn.toFixed(2);
            draw();
            if (selected) {
                updateReturns(selected.r, selected.c);
            }
        }

        function resetAll() {
            V = V.map((_, i) => isTerminal(Math.floor(i / GRID.cols), i % GRID.cols) ? 0 : 0);
            returns = Array.from({ length: GRID.rows * GRID.cols }, () => []);
            episode = 0;
            avgReturns = [];
            recentVisits = [];
            episodeChip.textContent = "0";
            returnChip.textContent = "–";
            draw();
        }

        function drawGrid() {
            const w = gridCanvas.width;
            const h = gridCanvas.height;
            gridCtx.clearRect(0, 0, w, h);
            const pad = 20;
            const cellW = (w - 2 * pad) / GRID.cols;
            const cellH = (h - 2 * pad) / GRID.rows;

            const minV = Math.min(...V);
            const maxV = Math.max(...V);
            const range = Math.max(1e-6, maxV - minV);

            for (let r = 0; r < GRID.rows; r++) {
                for (let c = 0; c < GRID.cols; c++) {
                    const i = idx(r, c);
                    const x = pad + c * cellW;
                    const y = pad + r * cellH;
                    const v = V[i];
                    const t = (v - minV) / range;
                    const color = `rgba(122, 162, 255, ${0.15 + 0.65 * t})`;
                    gridCtx.fillStyle = color;
                    gridCtx.fillRect(x, y, cellW, cellH);
                    gridCtx.strokeStyle = "rgba(255,255,255,0.15)";
                    gridCtx.strokeRect(x, y, cellW, cellH);

                    if (isTerminal(r, c)) {
                        gridCtx.fillStyle = "rgba(118, 247, 196, 0.25)";
                        gridCtx.fillRect(x, y, cellW, cellH);
                    }

                    gridCtx.fillStyle = "#e9eefc";
                    gridCtx.font = "14px ui-monospace";
                    gridCtx.fillText(v.toFixed(2), x + 8, y + 18);

                    if (!isTerminal(r, c)) {
                        const actions = greedyActions(r, c);
                        gridCtx.strokeStyle = "#76f7c4";
                        gridCtx.lineWidth = 2;
                        actions.forEach(a => {
                            const cx = x + cellW / 2;
                            const cy = y + cellH / 2 + 6;
                            const dx = a.dc * (cellW * 0.18);
                            const dy = a.dr * (cellH * 0.18);
                            gridCtx.beginPath();
                            gridCtx.moveTo(cx, cy);
                            gridCtx.lineTo(cx + dx, cy + dy);
                            gridCtx.stroke();
                            gridCtx.beginPath();
                            gridCtx.arc(cx + dx, cy + dy, 3, 0, Math.PI * 2);
                            gridCtx.fillStyle = "#76f7c4";
                            gridCtx.fill();
                        });
                    }

                    if (selected && selected.r === r && selected.c === c) {
                        gridCtx.strokeStyle = "#ffcc66";
                        gridCtx.lineWidth = 3;
                        gridCtx.strokeRect(x + 2, y + 2, cellW - 4, cellH - 4);
                    }
                }
            }
        }

        function drawReturns() {
            const w = returnCanvas.width;
            const h = returnCanvas.height;
            returnCtx.clearRect(0, 0, w, h);
            const pad = 30;
            returnCtx.strokeStyle = "rgba(255,255,255,0.12)";
            returnCtx.strokeRect(pad, pad, w - 2 * pad, h - 2 * pad);

            if (avgReturns.length === 0) return;
            const maxR = Math.max(...avgReturns);
            const minR = Math.min(...avgReturns);
            const range = Math.max(1e-6, maxR - minR);
            returnCtx.strokeStyle = "#7aa2ff";
            returnCtx.lineWidth = 2;
            returnCtx.beginPath();
            avgReturns.forEach((d, i) => {
                const x = pad + (i / Math.max(1, avgReturns.length - 1)) * (w - 2 * pad);
                const y = h - pad - ((d - minR) / range) * (h - 2 * pad);
                if (i === 0) returnCtx.moveTo(x, y);
                else returnCtx.lineTo(x, y);
            });
            returnCtx.stroke();

            returnCtx.fillStyle = "#a9b4d6";
            returnCtx.font = "12px ui-monospace";
            returnCtx.fillText(`episodes: ${episode}`, pad + 6, pad + 14);
        }

        function draw() {
            drawGrid();
            drawReturns();
        }

        function updateReturns(r, c) {
            selected = { r, c };
            stateChip.textContent = `(${r}, ${c})`;
            returnsTable.innerHTML = "";
            const entries = recentVisits.filter(v => v.r === r && v.c === c).slice(-12).reverse();
            if (entries.length === 0) {
                returnsHint.textContent = "No sampled returns for this state yet.";
                return;
            }
            returnsHint.textContent = "Recent Monte Carlo returns for selected state.";
            entries.forEach(item => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${item.episode}</td>
                    <td>${item.step}</td>
                    <td>${item.G.toFixed(3)}</td>
                `;
                returnsTable.appendChild(tr);
            });
        }

        gridCanvas.addEventListener("click", (e) => {
            const rect = gridCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (gridCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (gridCanvas.height / rect.height);
            const pad = 20;
            const cellW = (gridCanvas.width - 2 * pad) / GRID.cols;
            const cellH = (gridCanvas.height - 2 * pad) / GRID.rows;
            const c = Math.floor((x - pad) / cellW);
            const r = Math.floor((y - pad) / cellH);
            if (r >= 0 && r < GRID.rows && c >= 0 && c < GRID.cols) {
                updateReturns(r, c);
                draw();
            }
        });

        document.getElementById("run").addEventListener("click", () => {
            runBatch(parseInt(episodesEl.value, 10));
        });
        document.getElementById("reset").addEventListener("click", () => {
            resetAll();
            updateReturns(1, 1);
        });
        document.getElementById("play").addEventListener("click", () => {
            if (timer) return;
            timer = setInterval(() => runBatch(parseInt(episodesEl.value, 10)), 500);
        });
        document.getElementById("stop").addEventListener("click", () => {
            clearInterval(timer);
            timer = null;
        });
        gammaEl.addEventListener("input", () => {
            gammaValEl.textContent = parseFloat(gammaEl.value).toFixed(2);
            draw();
        });
        estimatorEl.addEventListener("change", () => {
            draw();
        });

        gammaValEl.textContent = parseFloat(gammaEl.value).toFixed(2);
        resetAll();
        updateReturns(1, 1);
    </script>
</body>

</html>
